name: build

on:
  push:
    branches:
      - master
    tags:
      - 'v*'  # Also trigger on version tags for releases
  pull_request:
    branches:
      - master
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v1.0.0)'
        required: true
        default: 'v0.1.0'
      release_name:
        description: 'Release name (optional)'
        required: false
        default: ''
      prerelease:
        description: 'Mark as prerelease'
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  pull-requests: write

env:
  CARGO_TERM_COLOR: always

jobs:
  # CI job - runs on every push/PR to master
  ci:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          components: rustfmt, clippy
          override: true

      - name: Cache cargo dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Check formatting
        run: cargo fmt -- --check

      - name: Run clippy
        run: cargo clippy -- -W clippy::pedantic -W clippy::nursery -D warnings

      - name: Run tests
        run: cargo test

      - name: Build
        run: cargo build --release

  # Release job - only runs on version tags or manual dispatch
  release:
    runs-on: ubuntu-latest
    needs: ci
    if: startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Cache cargo dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-cross-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-cross-
            ${{ runner.os }}-cargo-

      - name: Install cross-compilation tools
        run: |
          # Install musl tools for static linking
          sudo apt-get update
          sudo apt-get install -y musl-tools musl-dev
          
          # Install cross compilation tool (use specific stable version)
          cargo install cross --version 0.2.5
          
          # Add required targets
          rustup target add x86_64-unknown-linux-gnu
          rustup target add x86_64-unknown-linux-musl
          rustup target add aarch64-unknown-linux-gnu
          rustup target add aarch64-unknown-linux-musl
          
          # Setup Docker for cross-compilation
          docker --version
          
          # Pre-pull cross-compilation images to avoid timeout issues
          echo "Pre-pulling cross-compilation Docker images..."
          docker pull ghcr.io/cross-rs/aarch64-unknown-linux-gnu:main || true
          docker pull ghcr.io/cross-rs/aarch64-unknown-linux-musl:main || true

      - name: Build release binaries
        timeout-minutes: 30  # Increase timeout for cross-compilation
        env:
          CROSS_CONTAINER_IN_CONTAINER: true
          HOSTNAME: github-actions
          USER: runner
          HOME: /home/runner
          RUST_LOG: debug
        run: |
          mkdir -p release-artifacts
          
          # Show available targets and tools
          echo "Available Rust targets:"
          rustup target list --installed
          echo "Cross version:"
          cross --version
          echo "Docker version:"
          docker --version
          echo "Environment variables:"
          echo "HOSTNAME: $HOSTNAME"
          echo "USER: $USER"
          echo "HOME: $HOME"
          
          # Build for different platforms
          echo "Building for x86_64-unknown-linux-gnu..."
          cargo build --release --target x86_64-unknown-linux-gnu
          
          echo "Building for x86_64-unknown-linux-musl..."
          # Try using cargo directly for musl with system tools
          CC_x86_64_unknown_linux_musl=musl-gcc cargo build --release --target x86_64-unknown-linux-musl
          
          echo "Building for aarch64-unknown-linux-gnu..."
          # ARM64 build is now mandatory - fail if it doesn't work
          HOSTNAME=github-actions USER=runner HOME=/home/runner cross build --release --target aarch64-unknown-linux-gnu --verbose
          
          echo "Building for aarch64-unknown-linux-musl..."
          # ARM64 musl build is now mandatory - fail if it doesn't work
          HOSTNAME=github-actions USER=runner HOME=/home/runner cross build --release --target aarch64-unknown-linux-musl --verbose
          
          # Copy binaries (all should exist now since builds are mandatory)
          cp target/x86_64-unknown-linux-gnu/release/text-to-cypher release-artifacts/text-to-cypher-linux-x86_64
          cp target/x86_64-unknown-linux-musl/release/text-to-cypher release-artifacts/text-to-cypher-linux-x86_64-musl
          cp target/aarch64-unknown-linux-gnu/release/text-to-cypher release-artifacts/text-to-cypher-linux-aarch64
          cp target/aarch64-unknown-linux-musl/release/text-to-cypher release-artifacts/text-to-cypher-linux-aarch64-musl
          
          echo "✅ All binaries (x86_64 and ARM64) built successfully"
          
          # Copy templates directory
          cp -r templates release-artifacts/
          
          # Create complete packages with templates
          cd release-artifacts
          
          # Create tar.gz packages that include templates
          mkdir -p packages
          for binary in text-to-cypher-linux-*; do
            if [ -f "$binary" ]; then
              package_name="${binary}.tar.gz"
              echo "Creating package: $package_name"
              # Create a temporary directory for this package
              temp_dir="temp_${binary}"
              mkdir -p "$temp_dir"
              # Copy binary with standard name and templates
              cp "$binary" "$temp_dir/text-to-cypher"
              cp -r templates "$temp_dir/"
              # Create tar from the temp directory
              tar -czf "packages/${package_name}" -C "$temp_dir" .
              # Clean up temp directory
              rm -rf "$temp_dir"
              echo "✅ Created package: packages/$package_name"
            fi
          done
          
          # Create checksums for packages only
          sha256sum packages/*.tar.gz > checksums.txt

      - name: Create installation script
        run: |
          cat > release-artifacts/install.sh << 'EOF'
          #!/bin/bash
          set -e
          
          # Text-to-Cypher Installation Script
          REPO="barakb/text-to-cypher"
          BINARY_NAME="text-to-cypher"
          
          # Parse arguments
          INSTALL_SYSTEM=false
          
          for arg in "$@"; do
            case $arg in
              --install)
                INSTALL_SYSTEM=true
                ;;
              *)
                ;;
            esac
          done
          
          # Detect architecture
          ARCH=$(uname -m)
          OS=$(uname -s)
          
          case "$OS" in
            Linux*)
              case "$ARCH" in
                x86_64)  PLATFORM="linux-x86_64-musl" ;;  # Prefer musl for better compatibility
                aarch64) PLATFORM="linux-aarch64-musl" ;; # Prefer musl for better compatibility
                arm64)   PLATFORM="linux-aarch64-musl" ;; # Prefer musl for better compatibility
                *) echo "Unsupported architecture: $ARCH"; exit 1 ;;
              esac
              ;;
            Darwin*)
              case "$ARCH" in
                x86_64) PLATFORM="darwin-x86_64" ;;
                arm64)  PLATFORM="darwin-aarch64" ;;
                *) echo "Unsupported architecture: $ARCH"; exit 1 ;;
              esac
              ;;
            *) echo "Unsupported OS: $OS"; exit 1 ;;
          esac
          
          # Get latest release
          LATEST_RELEASE=$(curl -s "https://api.github.com/repos/$REPO/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
          
          # Download complete package with templates (always includes templates)
          DOWNLOAD_URL="https://github.com/$REPO/releases/download/$LATEST_RELEASE/packages/$BINARY_NAME-$PLATFORM.tar.gz"
          echo "Downloading $BINARY_NAME $LATEST_RELEASE (with templates) for $PLATFORM..."
          
          # Download and extract package
          if command -v curl >/dev/null 2>&1; then
            curl -L "$DOWNLOAD_URL" -o "$BINARY_NAME.tar.gz"
          elif command -v wget >/dev/null 2>&1; then
            wget "$DOWNLOAD_URL" -O "$BINARY_NAME.tar.gz"
          else
            echo "Error: curl or wget is required"
            exit 1
          fi
          
          # Extract the package
          tar -xzf "$BINARY_NAME.tar.gz"
          rm "$BINARY_NAME.tar.gz"
          
          echo "Downloaded $BINARY_NAME with templates!"
          echo "Files extracted:"
          echo "  - $BINARY_NAME (executable)"
          echo "  - templates/ (directory)"
          
          # Install to system path (optional)
          if [ "$INSTALL_SYSTEM" = "true" ]; then
            sudo mv "$BINARY_NAME" /usr/local/bin/
            sudo mkdir -p /usr/local/share/text-to-cypher
            sudo cp -r templates /usr/local/share/text-to-cypher/
            echo "$BINARY_NAME installed to /usr/local/bin/"
            echo "Templates installed to /usr/local/share/text-to-cypher/templates/"
          else
            echo "$BINARY_NAME downloaded successfully!"
            echo "Run with: ./$BINARY_NAME"
            echo "Templates available in: ./templates/"
            echo ""
            echo "Usage options:"
            echo "  $0 --install    # Install system-wide"
          fi
          EOF
          chmod +x release-artifacts/install.sh

      - name: Generate release tag
        id: tag
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Use manual input version
            TAG="${{ github.event.inputs.version }}"
            RELEASE_NAME="${{ github.event.inputs.release_name }}"
            if [ -z "$RELEASE_NAME" ]; then
              RELEASE_NAME="Release $TAG"
            fi
          else
            # Use the tag from the push event
            TAG="${GITHUB_REF#refs/tags/}"
            RELEASE_NAME="Release $TAG"
          fi
          
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "release_name=$RELEASE_NAME" >> $GITHUB_OUTPUT
          echo "prerelease=${{ github.event.inputs.prerelease || 'false' }}" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          name: ${{ steps.tag.outputs.release_name }}
          prerelease: ${{ steps.tag.outputs.prerelease }}
          body: |
            ## 🚀 Text-to-Cypher ${{ steps.tag.outputs.tag }}
            
            **Built from commit:** ${{ github.sha }}
            **Release Type:** ${{ steps.tag.outputs.prerelease == 'true' && 'Pre-release' || 'Stable' }}
            
            ### 📦 Quick Installation:
            ```bash
            # One-line install (Linux/macOS)
            curl -sSL https://github.com/${{ github.repository }}/releases/download/${{ steps.tag.outputs.tag }}/install.sh | bash
            
            # Or install system-wide
            curl -sSL https://github.com/${{ github.repository }}/releases/download/${{ steps.tag.outputs.tag }}/install.sh | bash -s -- --install
            ```
            
            ### 📋 Manual Downloads:
            - **Complete Packages** (includes binary + templates):
              - `packages/text-to-cypher-linux-x86_64.tar.gz` (x86_64 with glibc)
              - `packages/text-to-cypher-linux-x86_64-musl.tar.gz` (x86_64 static)
              - `packages/text-to-cypher-linux-aarch64.tar.gz` (ARM64 with glibc)
              - `packages/text-to-cypher-linux-aarch64-musl.tar.gz` (ARM64 static)
            - **Checksums**: `checksums.txt`
            
            ### 🐳 Use in Your Dockerfiles:
            ```dockerfile
            # Download and use in your Dockerfile
            FROM alpine:latest
            RUN apk add --no-cache wget tar && \
                wget https://github.com/${{ github.repository }}/releases/download/${{ steps.tag.outputs.tag }}/packages/text-to-cypher-linux-x86_64-musl.tar.gz && \
                tar -xzf text-to-cypher-linux-x86_64-musl.tar.gz && \
                mv text-to-cypher /usr/local/bin/text-to-cypher && \
                mv templates /usr/local/share/text-to-cypher-templates && \
                rm text-to-cypher-linux-x86_64-musl.tar.gz
            ENV TEMPLATES_DIR=/usr/local/share/text-to-cypher-templates
            CMD ["text-to-cypher"]
            ```
          files: |
            release-artifacts/packages/*
            release-artifacts/checksums.txt
            release-artifacts/install.sh
            release-artifacts/text-to-cypher-linux-*
          draft: false

  # Release cleanup job - only runs after successful release
  cleanup-old-releases:
    runs-on: ubuntu-latest
    needs: release
    if: startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch'
    steps:
      - name: Cleanup old releases
        uses: actions/github-script@v7
        with:
          script: |
            const { data: releases } = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            
            // Sort releases by creation date (newest first)
            const sortedReleases = releases.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            
            // Keep only the latest 10 releases
            const releasesToDelete = sortedReleases.slice(10);
            
            console.log(`Found ${releases.length} total releases`);
            console.log(`Keeping latest 10 releases`);
            console.log(`Deleting ${releasesToDelete.length} old releases`);
            
            for (const release of releasesToDelete) {
              try {
                console.log(`Deleting release: ${release.tag_name} (${release.name})`);
                await github.rest.repos.deleteRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: release.id
                });
                
                // Also delete the associated tag
                try {
                  await github.rest.git.deleteRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `tags/${release.tag_name}`
                  });
                  console.log(`Deleted tag: ${release.tag_name}`);
                } catch (tagError) {
                  console.log(`Failed to delete tag ${release.tag_name}: ${tagError.message}`);
                }
              } catch (error) {
                console.log(`Failed to delete release ${release.tag_name}: ${error.message}`);
              }
            }
            
            console.log('Cleanup completed');