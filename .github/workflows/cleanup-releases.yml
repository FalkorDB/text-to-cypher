name: Cleanup Old Releases

on:
  schedule:
    # Run weekly on Sundays at 2 AM UTC
    - cron: '0 2 * * 0'
  release:
    types: [published]
  workflow_run:
    workflows: ["build"]
    types:
      - completed
    branches: [master]
  workflow_dispatch:
    inputs:
      keep_releases:
        description: 'Number of stable releases to keep'
        required: true
        default: '10'
        type: number
      keep_prereleases:
        description: 'Number of prereleases to keep'
        required: true
        default: '1'
        type: number

permissions:
  contents: write

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Check if cleanup should run
        id: should_run
        run: |
          # For manual/scheduled runs, always run
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] || [ "${{ github.event_name }}" = "schedule" ]; then
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "reason=Manual or scheduled cleanup" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # For release events, only run if it's a prerelease
          if [ "${{ github.event_name }}" = "release" ] && [ "${{ github.event.release.prerelease }}" = "true" ]; then
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "reason=New prerelease published: ${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # For workflow_run, check if it was triggered by a prerelease tag
          if [ "${{ github.event_name }}" = "workflow_run" ] && [[ "${{ github.event.workflow_run.head_branch }}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+-(alpha|beta|rc) ]]; then
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "reason=Prerelease build completed: ${{ github.event.workflow_run.head_branch }}" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "should_run=false" >> $GITHUB_OUTPUT
          echo "reason=Not a prerelease event, skipping cleanup" >> $GITHUB_OUTPUT

      - name: Cleanup old releases
        if: steps.should_run.outputs.should_run == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            console.log("üßπ Starting release cleanup...");
            console.log("Trigger reason: ${{ steps.should_run.outputs.reason }}");
            
            const keepReleases = ${{ github.event.inputs.keep_releases || 10 }};
            const keepPrereleases = ${{ github.event.inputs.keep_prereleases || 1 }};
            
            console.log(`Configuration: Keep ${keepReleases} stable releases, ${keepPrereleases} prereleases`);
            
            const { data: releases } = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });
            
            // Sort releases by creation date (newest first)
            const sortedReleases = releases.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            
            // Separate stable releases from prereleases
            const stableReleases = sortedReleases.filter(release => !release.prerelease);
            const prereleases = sortedReleases.filter(release => release.prerelease);
            
            // Determine which releases to delete
            const stableToDelete = stableReleases.slice(keepReleases);
            const prereleasesToDelete = prereleases.slice(keepPrereleases);
            const releasesToDelete = [...stableToDelete, ...prereleasesToDelete];
            
            console.log(`Found ${releases.length} total releases:`);
            console.log(`  - ${stableReleases.length} stable releases (keeping latest ${keepReleases})`);
            console.log(`  - ${prereleases.length} prereleases (keeping latest ${keepPrereleases})`);
            console.log(`Deleting ${releasesToDelete.length} old releases (${stableToDelete.length} stable + ${prereleasesToDelete.length} prereleases)`);
            
            if (releasesToDelete.length === 0) {
              console.log('No releases to delete');
              return;
            }
            
            let deletedCount = 0;
            let failedCount = 0;
            
            for (const release of releasesToDelete) {
              try {
                const releaseType = release.prerelease ? 'prerelease' : 'stable';
                console.log(`Deleting ${releaseType}: ${release.tag_name} (${release.name}) created ${release.created_at}`);
                await github.rest.repos.deleteRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: release.id
                });
                
                // Also delete the associated tag
                try {
                  await github.rest.git.deleteRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `tags/${release.tag_name}`
                  });
                  console.log(`‚úÖ Deleted ${releaseType} and tag: ${release.tag_name}`);
                  deletedCount++;
                } catch (tagError) {
                  console.log(`‚ö†Ô∏è  Deleted ${releaseType} but failed to delete tag ${release.tag_name}: ${tagError.message}`);
                  deletedCount++;
                }
              } catch (error) {
                console.log(`‚ùå Failed to delete release ${release.tag_name}: ${error.message}`);
                failedCount++;
              }
            }
            
            console.log(`\nüìä Cleanup Summary:`);
            console.log(`‚úÖ Successfully deleted: ${deletedCount} releases`);
            console.log(`‚ùå Failed to delete: ${failedCount} releases`);
            console.log(`üéØ Stable releases remaining: ${stableReleases.length - stableToDelete.length}`);
            console.log(`üéØ Prereleases remaining: ${prereleases.length - prereleasesToDelete.length}`);
            console.log(`üéØ Total releases remaining: ${releases.length - deletedCount}`);
