name: Docker Release Build

on:
  release:
    types: [published]
  workflow_run:
    workflows: ["build"]
    types:
      - completed
    # Only trigger for tag-based builds, not regular pushes to master
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., v0.1.0-beta.1)'
        required: true
        default: 'v0.1.0-beta.1'

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io

jobs:
  docker-build:
    runs-on: ubuntu-latest
    # Only run if the build workflow was triggered by a tag
    if: ${{ github.event_name == 'release' || github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && startsWith(github.event.workflow_run.head_branch, 'v')) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Extract release version
        id: extract_version
        run: |
          # Extract version from different trigger types
          if [ "${{ github.event_name }}" = "release" ]; then
            RELEASE_TAG="${{ github.event.release.tag_name }}"
          elif [ "${{ github.event_name }}" = "workflow_run" ]; then
            # For workflow_run, extract from the head branch if it's a tag
            if [[ "${{ github.event.workflow_run.head_branch }}" =~ ^v[0-9] ]]; then
              RELEASE_TAG="${{ github.event.workflow_run.head_branch }}"
            else
              echo "Workflow run was not triggered by a tag, skipping Docker build"
              exit 0
            fi
          elif [ "${{ github.event_name }}" = "push" ] && [ "${{ github.ref_type }}" = "tag" ]; then
            RELEASE_TAG="${{ github.ref_name }}"
          else
            RELEASE_TAG="${{ github.event.inputs.version }}"
          fi
          
          # Only proceed if workflow_run was successful (when applicable)
          if [ "${{ github.event_name }}" = "workflow_run" ] && [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
            echo "Build workflow did not complete successfully, skipping Docker build"
            exit 0
          fi
          
          VERSION="${RELEASE_TAG#v}"
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "release_tag=${RELEASE_TAG}" >> $GITHUB_OUTPUT
          echo "Building Docker image for release: ${RELEASE_TAG}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Make docker-build.sh executable
        run: chmod +x ./docker-build.sh

      - name: Wait for release assets to be available
        run: |
          echo "ðŸš€ Starting asset availability check..."
          VERSION="${{ steps.extract_version.outputs.release_tag }}"
          
          echo "ðŸ” Debug: Version information:"
          echo "  Raw release_tag: '${{ steps.extract_version.outputs.release_tag }}'"
          echo "  Computed VERSION: '${VERSION}'"
          echo "  Event name: '${{ github.event_name }}'"
          
          # Fix: Use the clean version without 'v' prefix for URL construction
          CLEAN_VERSION="${VERSION#v}"
          echo "  Clean version for URLs: '${CLEAN_VERSION}'"
          
          # Enhanced asset checking with build workflow status monitoring
          MAX_ATTEMPTS=60  # 30 minutes total (60 Ã— 30 seconds)
          ATTEMPT=1
          
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: Checking release assets availability..."
            
            # Check build workflow status first
            if [ "${{ github.event_name }}" = "workflow_run" ]; then
              BUILD_STATUS="${{ github.event.workflow_run.conclusion }}"
              echo "ðŸ“Š Build workflow status: $BUILD_STATUS"
              if [ "$BUILD_STATUS" = "failure" ] || [ "$BUILD_STATUS" = "cancelled" ]; then
                echo "âŒ Build workflow failed/cancelled - no assets will be available"
                exit 1
              fi
            fi
            
            # Check if both required assets exist (root level .tar.gz files with templates)
            X86_URL="https://github.com/barakb/text-to-cypher/releases/download/v${CLEAN_VERSION}/text-to-cypher-linux-x86_64-musl.tar.gz"
            ARM_URL="https://github.com/barakb/text-to-cypher/releases/download/v${CLEAN_VERSION}/text-to-cypher-linux-aarch64-musl.tar.gz"
            
            echo "ðŸ” Debug: Checking asset URLs:"
            echo "  VERSION: ${VERSION}"
            echo "  CLEAN_VERSION: ${CLEAN_VERSION}"
            echo "  X86_URL: ${X86_URL}"
            echo "  ARM_URL: ${ARM_URL}"
            
            echo "ðŸŒ Testing x86_64 asset..."
            X86_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$X86_URL")
            echo "  Raw curl exit code: $?"
            echo "  HTTP status: $X86_STATUS"
            
            echo "ðŸŒ Testing aarch64 asset..."
            ARM_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$ARM_URL")
            echo "  Raw curl exit code: $?"
            echo "  HTTP status: $ARM_STATUS"
            
            # Test with verbose curl for debugging
            echo "ðŸ” Detailed x86_64 asset check:"
            curl -v -s -o /dev/null -w "Final HTTP code: %{http_code}\n" "$X86_URL" 2>&1 | head -10
            
            echo "ðŸ” Detailed aarch64 asset check:"
            curl -v -s -o /dev/null -w "Final HTTP code: %{http_code}\n" "$ARM_URL" 2>&1 | head -10
            
            # Accept both 200 (direct) and 302 (redirect) as success
            X86_OK=false
            ARM_OK=false
            
            echo "ðŸ§ª Evaluating x86_64 status (received: '$X86_STATUS'):"
            if [ "$X86_STATUS" = "200" ]; then
              X86_OK=true
              echo "  âœ… Status 200 - Direct download available"
            elif [ "$X86_STATUS" = "302" ]; then
              X86_OK=true
              echo "  âœ… Status 302 - Redirect (likely to S3/CDN)"
            else
              echo "  âŒ Unexpected status: '$X86_STATUS'"
              echo "  Expected: '200' or '302'"
            fi
            
            echo "ðŸ§ª Evaluating aarch64 status (received: '$ARM_STATUS'):"
            if [ "$ARM_STATUS" = "200" ]; then
              ARM_OK=true
              echo "  âœ… Status 200 - Direct download available"
            elif [ "$ARM_STATUS" = "302" ]; then
              ARM_OK=true
              echo "  âœ… Status 302 - Redirect (likely to S3/CDN)"
            else
              echo "  âŒ Unexpected status: '$ARM_STATUS'"
              echo "  Expected: '200' or '302'"
            fi
            
            echo "ðŸ“Š Asset availability summary:"
            echo "  x86_64: $X86_OK (status: $X86_STATUS)"
            echo "  aarch64: $ARM_OK (status: $ARM_STATUS)"
            
            # Both assets must be available
            echo "ðŸŽ¯ Decision logic evaluation:"
            echo "  X86_OK='$X86_OK' (type: $(echo "$X86_OK" | wc -c) chars)"
            echo "  ARM_OK='$ARM_OK' (type: $(echo "$ARM_OK" | wc -c) chars)"
            echo "  String comparison test:"
            echo "    X86_OK == 'true': $([ "$X86_OK" = "true" ] && echo "YES" || echo "NO")"
            echo "    ARM_OK == 'true': $([ "$ARM_OK" = "true" ] && echo "YES" || echo "NO")"
            echo "  Combined condition: $([ "$X86_OK" = "true" ] && [ "$ARM_OK" = "true" ] && echo "BOTH_TRUE" || echo "NOT_BOTH_TRUE")"
            
            if [ "$X86_OK" = "true" ] && [ "$ARM_OK" = "true" ]; then
              echo "ðŸŽ‰ All release assets are available!"
              break
            else
              echo "â³ Waiting for assets to become available..."
              echo "  Missing: $([ "$X86_OK" != "true" ] && echo "x86_64 " || echo "")$([ "$ARM_OK" != "true" ] && echo "aarch64" || echo "")"
            fi
            
            # Provide helpful status updates
            if [ $((ATTEMPT % 5)) -eq 0 ]; then
              ELAPSED_MINUTES=$((ATTEMPT * 30 / 60))
              echo "ðŸ“ˆ Progress update after $ELAPSED_MINUTES minutes:"
              echo "  - x86_64 build: $([ "$X86_OK" = "true" ] && echo "âœ… Complete" || echo "ðŸ”„ In progress")"
              echo "  - aarch64 build: $([ "$ARM_OK" = "true" ] && echo "âœ… Complete" || echo "ðŸ”„ In progress")"
              echo "  - Note: ARM64 builds typically take longer than x86_64"
            fi
            
            if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
              echo "âŒ Timeout after $MAX_ATTEMPTS attempts (30 minutes)"
              echo "Final asset status:"
              echo "  - x86_64: $X86_STATUS ($([ "$X86_OK" = "true" ] && echo "âœ… Available" || echo "âŒ Missing"))"
              echo "  - aarch64: $ARM_STATUS ($([ "$ARM_OK" = "true" ] && echo "âœ… Available" || echo "âŒ Missing"))"
              echo ""
              echo "Possible causes:"
              echo "1. Cross-platform build taking longer than 30 minutes"
              echo "2. Build workflow failed for one or both architectures"
              echo "3. GitHub release asset upload issues"
              echo ""
              echo "Next steps:"
              echo "1. Check build workflow: https://github.com/barakb/text-to-cypher/actions"
              echo "2. Check release assets: https://github.com/barakb/text-to-cypher/releases/tag/v$CLEAN_VERSION"
              echo "3. Retry this workflow manually if builds completed"
              exit 1
            fi
            
            echo "â³ Waiting 30 seconds... ($(($ATTEMPT * 30 / 60)) min elapsed, up to 30 min total)"
            sleep 30
            ATTEMPT=$((ATTEMPT + 1))
          done

      - name: Build and push Docker images
        run: |
          # Build and push to GitHub Container Registry
          ./docker-build.sh \
            --version "${{ steps.extract_version.outputs.release_tag }}" \
            --platforms "linux/amd64,linux/arm64" \
            --image-name "text-to-cypher" \
            --registry "${{ env.REGISTRY }}/${{ github.repository_owner }}" \
            --push
          
          # Also build and push without registry prefix for local/Docker Hub use
          ./docker-build.sh \
            --version "${{ steps.extract_version.outputs.release_tag }}" \
            --platforms "linux/amd64,linux/arm64" \
            --image-name "text-to-cypher" \
            --push

  # Verify the built images
  verify-images:
    runs-on: ubuntu-latest
    needs: docker-build
    strategy:
      matrix:
        platform: [linux/amd64, linux/arm64]
    steps:
      - name: Extract release version
        id: extract_version
        run: |
          # Extract version from different trigger types
          if [ "${{ github.event_name }}" = "release" ]; then
            RELEASE_TAG="${{ github.event.release.tag_name }}"
          elif [ "${{ github.event_name }}" = "workflow_run" ]; then
            # For workflow_run, extract from the head branch if it's a tag
            if [[ "${{ github.event.workflow_run.head_branch }}" =~ ^v[0-9] ]]; then
              RELEASE_TAG="${{ github.event.workflow_run.head_branch }}"
            else
              echo "Not a tag-triggered workflow run, skipping"
              exit 0
            fi
          elif [ "${{ github.event_name }}" = "push" ] && [ "${{ github.ref_type }}" = "tag" ]; then
            RELEASE_TAG="${{ github.ref_name }}"
          else
            RELEASE_TAG="${{ github.event.inputs.version }}"
          fi
          echo "release_tag=${RELEASE_TAG}" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify image exists and runs
        run: |
          # Pull and test the specific platform image from GitHub Container Registry
          PLATFORM="${{ matrix.platform }}"
          IMAGE="${{ env.REGISTRY }}/${{ github.repository_owner }}/text-to-cypher:${{ steps.extract_version.outputs.release_tag }}"
          
          echo "Verifying image: ${IMAGE} for platform: ${PLATFORM}"
          
          # Pull the image for the specific platform
          docker pull --platform="${PLATFORM}" "${IMAGE}"
          
          # Basic verification - check if the binary exists and is executable
          docker run --rm --platform="${PLATFORM}" "${IMAGE}" /app/text-to-cypher --help || true
          
          echo "âœ… Image verification completed for ${PLATFORM}"

  # Update deployment configurations (optional)
  update-deployment:
    runs-on: ubuntu-latest
    needs: [docker-build, verify-images]
    if: ${{ !github.event.release.prerelease || github.event_name == 'workflow_dispatch' || github.event_name == 'workflow_run' }}
    steps:
      - name: Extract release version
        id: extract_version
        run: |
          # Extract version from different trigger types
          if [ "${{ github.event_name }}" = "release" ]; then
            RELEASE_TAG="${{ github.event.release.tag_name }}"
          elif [ "${{ github.event_name }}" = "workflow_run" ]; then
            # For workflow_run, extract from the head branch if it's a tag
            if [[ "${{ github.event.workflow_run.head_branch }}" =~ ^v[0-9] ]]; then
              RELEASE_TAG="${{ github.event.workflow_run.head_branch }}"
            else
              echo "Not a tag-triggered workflow run, skipping"
              exit 0
            fi
          elif [ "${{ github.event_name }}" = "push" ] && [ "${{ github.ref_type }}" = "tag" ]; then
            RELEASE_TAG="${{ github.ref_name }}"
          else
            RELEASE_TAG="${{ github.event.inputs.version }}"
          fi
          echo "release_tag=${RELEASE_TAG}" >> $GITHUB_OUTPUT

      - name: Update deployment examples
        run: |
          echo "ðŸš€ Docker images built and verified for release: ${{ steps.extract_version.outputs.release_tag }}"
          echo ""
          echo "ðŸ“¦ Available images:"
          echo "  - ${{ env.REGISTRY }}/${{ github.repository_owner }}/text-to-cypher:${{ steps.extract_version.outputs.release_tag }}"
          echo "  - ${{ env.REGISTRY }}/${{ github.repository_owner }}/text-to-cypher:latest"
          echo "  - text-to-cypher:${{ steps.extract_version.outputs.release_tag }}"
          echo "  - text-to-cypher:latest"
          echo ""
          echo "ðŸƒ To run the latest release:"
          echo "  docker run -p 6379:6379 -p 3000:3000 -p 8080:8080 -p 3001:3001 \\"
          echo "    -e DEFAULT_MODEL=gpt-4o-mini -e DEFAULT_KEY=your-key \\"
          echo "    ${{ env.REGISTRY }}/${{ github.repository_owner }}/text-to-cypher:${{ steps.extract_version.outputs.release_tag }}"
          echo ""
          echo "ðŸ“‹ Available platforms: linux/amd64, linux/arm64"

      - name: Create deployment summary
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # ðŸ³ Docker Release Build Complete
          
          ## Release Information
          - **Version**: \`${{ steps.extract_version.outputs.release_tag }}\`
          - **Repository**: \`${{ github.repository }}\`
          - **Platforms**: linux/amd64, linux/arm64
          
          ## Available Images
          - \`${{ env.REGISTRY }}/${{ github.repository_owner }}/text-to-cypher:${{ steps.extract_version.outputs.release_tag }}\`
          - \`${{ env.REGISTRY }}/${{ github.repository_owner }}/text-to-cypher:latest\`
          - \`text-to-cypher:${{ steps.extract_version.outputs.release_tag }}\`
          - \`text-to-cypher:latest\`
          
          ## Quick Start
          \`\`\`bash
          docker run -p 6379:6379 -p 3000:3000 -p 8080:8080 -p 3001:3001 \\
            -e DEFAULT_MODEL=gpt-4o-mini -e DEFAULT_KEY=your-key \\
            ${{ env.REGISTRY }}/${{ github.repository_owner }}/text-to-cypher:${{ steps.extract_version.outputs.release_tag }}
          \`\`\`
          
          ## Services
          - **Port 6379**: FalkorDB (Redis protocol)
          - **Port 3000**: FalkorDB web interface  
          - **Port 8080**: text-to-cypher HTTP API
          - **Port 3001**: text-to-cypher MCP server
          EOF
